<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - glTF loader</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="css/main.css">
    <script type="importmap">
{
  "imports": {
    "three": "./three/build/three.module.js"
  }
}
</script>
</head>


<body>
<div id="info">
    <h3>Alice in Wonderland in your browser</h3>
    <a href="/">Back to example list</a>
</div>

<script type="module">


    import * as THREE from 'three';
    import { OrbitControls } from './three/examples/jsm/controls/OrbitControls.js';
    import {ARButton} from './three/examples/jsm/webxr/ARButton.js';
    import {GLTFLoader} from './three/examples/jsm/loaders/GLTFLoader.js';



    let camera, scene, renderer;

    init();
    animate();

    function drawScene() {
        const groundColor = new THREE.MeshStandardMaterial({
            color: 0x275619,
            metalness: 0,
            roughness: 1.0,
            emissive: 0x0,
            fog: true
        });

        const cubeGeometry = new THREE.BoxGeometry(10, 10, 0.1);
        const ground = new THREE.Mesh(cubeGeometry, groundColor);

        ground.rotation.x = Math.PI / 2;
        ground.position.y = -0.03
        scene.add(ground)

        const loader = new GLTFLoader();
        loader.load('./models/cat/scene.gltf', function (gltf) {
                let model = gltf.scene;

                model.scale.set(0.1, 0.1, 0.1)
                model.position.set(2.3, 3.3, 1.4);
                model.rotation.x = Math.PI / 6
                scene.add(model);

            },
            (xhr) => console.log((xhr.loaded / xhr.total * 100) + '% loaded'),
            (e) => console.error(e));

        loader.load('./models/alice/scene.gltf', function (gltf) {
                let model = gltf.scene;

                model.position.set(2.2, 1, 3.5);
                model.rotation.y = Math.PI
                scene.add(model);

            },
            (xhr) => console.log((xhr.loaded / xhr.total * 100) + '% loaded'),
            (e) => console.error(e));


        loader.load('./models/tree/scene.gltf', function (gltf) {
                let model = gltf.scene;

                // model.scale.set(0.01, 0.01, 0.01)
                model.rotation.y = Math.PI + Math.PI / 6
                console.log(gltf)
                scene.add(model);

            },
            (xhr) => console.log((xhr.loaded / xhr.total * 100) + '% loaded'),
            (e) => console.error(e));
    }

    function init() {

        const container = document.createElement('div');
        document.body.appendChild(container);

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.25, 20);
        camera.position.set( 5, 5, 10 );
        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0xa0a0a0 );
        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        light.position.set(0.5, 1, 0.25);
        scene.add(light);


        document.body.appendChild(ARButton.createButton(renderer, {requiredFeatures: ['hit-test']}));

        drawScene();

        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1;
        renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild(renderer.domElement);

        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();


        const controls = new OrbitControls( camera, renderer.domElement );
        controls.enablePan = false;
        controls.minDistance = 5;
        controls.maxDistance = 50;

        window.addEventListener('resize', onWindowResize);

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);

        render();

    }

    function animate() {
        renderer.setAnimationLoop(render);
    }


    function render() {

        renderer.render(scene, camera);

    }

</script>

</body>
</html>
